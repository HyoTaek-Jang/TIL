사내에서 Kotlin으로 작성된 코드를 읽을 일이 생겨서 급하게 호다닥 정리한 글입니다.
추후 기억이 안날때 키워드를 참고하고자 작성한 글이기에 정돈되지 않거나, 자세하지 않을 수 있습니다.

# 변수

## var와 val

var와 val는 *가변과 불변*의 차이다.

var : variable - 가변
val : value - 불변

```kotlin
var number: Int
```

와 같은 형식으로 {변수 키워드} {변수명}: {타입}을 선언한다.

모든 변수는 val로 생성하고 필요한 경우 var로 변경한다.

## Primitive Type, Reference Type

자바에서는 boxing, unboxing에 대한 문제로 연산에 대해 primitive type을 권장했다.

그런데 코틀린에는 Primitive type이 명시적으로 존재하지 않는다. 그렇다면 성능상 불리할까?

_Nope!_

kotlin으로 작성된 코드를 compile하고 java로 decompile하면 알아서 잘 Reference Type으로 만들어진 코드를 Primitive Type으로 변환하여 실행되는 모습을 볼 수 있다.

```kotlin
fun main() {
    var a: Long = 10L
    var b: Long = 5L
    var c = a + b
    println(c)
}

```

->

```java
   public static final void main() {
      long a = 10L;
      long b = 5L;
      long c = a + b;
      System.out.println(c);
   }
```

## Nullable 변수

null은 개발에 큰 편의를 주지만 반대로 예상치 못한 버그 또한 많이 만들어냅니다.
따라서, Kotlin은 기본적으로 Null을 허용하지 않습니다.

Null을 사용하고 싶다면, 타입 뒤에 ?를 붙여서 사용이 가능합니다.

```kotlin
var num: Long? = 10L
```

## 객체 생성

예를 들어 Member라는 클래스가 있다고 합시다.

```java
Member member = new Member();
```

->

```kotlin
Member member = Member()
```

깔꼼하게 New를 생략하시면 됩니다.

# Null Handling

kotlin은 위에서도 말했듯이 기본적으로 Not Null입니다.
따라서, 최대한 NPE를 통해 발생할 수 있는 오류를 막습니다.

```kotlin
fun startWithA(str: String): Boolean {
    return str.startsWith("A");
}
```

해당 코드는 str도 Not Null이고 return type인 Boolean도 Not Null입니다.

만약 Null을 허용하고 싶으면 _?_ 를 붙여서 사용할 수 있습니다.

```kotlin
fun startWithA(str: String?): Boolean? {
    return str?.startsWith("A")
}
```

해당 코드를 해석해보겠습니다.

1. str은 null이 될 수 있다. -> `str: String?`
2. str이 null이면 startsWith는 실행하지 않고 null을 반환한다. -> `str?.startsWith("A")`
3. startWithA의 반환 값은 Null이 될 수 있다. -> `Boolean?`

## Safe Call, Elvis 연산자, !! 연산자

1. Safe Call `?.` - null이 아니면 뒤에 구문을 실행하고, null이면 null로 냅둔다.
2. Elvis `?:` - 앞의 연산 결과가 null이면 뒤의 값을 사용한다.
3. !! - Nullable이지만 곧 죽어도 Null일리가 없을 경우 사용합니다. `str!!.startsWith("A")`

3번의 경우 만약 Null이 들어온다면 NPE가 발생합니다.

# Type

## 타입 추론

1. Kotlin은 선언된 기본 값을 통해 타입을 추론합니다.
   1. val num = 3 -> Int로 추론
   2. val num = 3L -> Long으로 추론

## 타입 캐스팅

1. 타입 변환이 명시적으로 이뤄집니다.
   1. 안되는 케이스
      ```kotlin
      val num = 5 // 암시적 Int 추론
      val longNum: Long = num // 안됨. Type Mismatch
      ```
   2. 가능한 경우
      ```kotlin
      val num = 5 // 암시적 Int 추론
      val longNum: Long = num.toLong() // 가능
      ```
2. custom 객체 캐스팅

   1. 변수 타입 확인

   ```kotlin
   fun test(obj: Any) {
       if (obj is Member) {
           val member = obj as Member
           println(member.name)
       }
   }
   ```

   특정 클래스의 타입임을 확인하고자 하면, `{변수명} is {Type}`을 사용하면 됩니다.

   특정 클래스의 타입이 아닌 것을 확인하고자 하면, `{변수명} !is {Type}`을 사용하면 됩니다.

   타입으로 변환은 `{변수명} as {Type}`

   `{변수명} as? {Type}`을 사용하면 변수가 null이거나 type이 아닐 땐 null을 반환합니다.

   2. 스마트 캐스팅

      ```kotlin
      println(obj.name)
      ```

      와 같은 형식으로 명시적 캐스팅 없이 스마트 캐스팅이 가능합니다.

## 특별한 Type 3가지. Any, Unit, Nothing

### Any

1. java의 object. 최상위 타입
2. Any 자체는 not null이다. nullable하려면 `Any?`를 사용!

### Unit

1. Java의 void

### Nothing

1. 함수가 정상적으로 끝나지 않음을 표현함
2. 무조건 예외를 반환하는 함수, 무한 루프

# String 사용법

## 문자열 변수 사용법

문자열에서 변수 사용하기! -> `${변수}`

```kotlin
val member = Member("taek")
val str = "my name is ${member.name}"
```

or

문자열에서 변수 사용하기! -> `$변수`

```kotlin
val member = Member("taek")
val str = "my name is $member.name"
```

하지만 `${변수}`의 사용법이 더욱 권장된다

## 멀티라인 문자열

```kotlin
val str = """
ABC
DEF
GHI
""".trimIndent()
```

*trimIndent()*는 라인 별로 앞에 공백을 제거해준다.
