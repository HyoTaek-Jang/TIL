사내에서 Kotlin으로 작성된 코드를 읽을 일이 생겨서 급하게 호다닥 정리한 글입니다.
추후 기억이 안날때 키워드를 참고하고자 작성한 글이기에 정돈되지 않거나, 자세하지 않을 수 있습니다.

# 변수

## var와 val

var와 val는 *가변과 불변*의 차이다.

var : variable - 가변
val : value - 불변

```kotlin
var number: Int
```

와 같은 형식으로 {변수 키워드} {변수명}: {타입}을 선언한다.

모든 변수는 val로 생성하고 필요한 경우 var로 변경한다.

## Primitive Type, Reference Type

자바에서는 boxing, unboxing에 대한 문제로 연산에 대해 primitive type을 권장했다.

그런데 코틀린에는 Primitive type이 명시적으로 존재하지 않는다. 그렇다면 성능상 불리할까?

_Nope!_

kotlin으로 작성된 코드를 compile하고 java로 decompile하면 알아서 잘 Reference Type으로 만들어진 코드를 Primitive Type으로 변환하여 실행되는 모습을 볼 수 있다.

```kotlin
fun main() {
    var a: Long = 10L
    var b: Long = 5L
    var c = a + b
    println(c)
}

```

->

```java
   public static final void main() {
      long a = 10L;
      long b = 5L;
      long c = a + b;
      System.out.println(c);
   }
```

## Nullable 변수

null은 개발에 큰 편의를 주지만 반대로 예상치 못한 버그 또한 많이 만들어냅니다.
따라서, Kotlin은 기본적으로 Null을 허용하지 않습니다.

Null을 사용하고 싶다면, 타입 뒤에 ?를 붙여서 사용이 가능합니다.

```kotlin
var num: Long? = 10L
```

## 객체 생성

예를 들어 Member라는 클래스가 있다고 합시다.

```java
Member member = new Member();
```

->

```kotlin
Member member = Member()
```

깔꼼하게 New를 생략하시면 됩니다.

# Null Handling

kotlin은 위에서도 말했듯이 기본적으로 Not Null입니다.
따라서, 최대한 NPE를 통해 발생할 수 있는 오류를 막습니다.

```kotlin
fun startWithA(str: String): Boolean {
    return str.startsWith("A");
}
```

해당 코드는 str도 Not Null이고 return type인 Boolean도 Not Null입니다.

만약 Null을 허용하고 싶으면 _?_ 를 붙여서 사용할 수 있습니다.

```kotlin
fun startWithA(str: String?): Boolean? {
    return str?.startsWith("A")
}
```

해당 코드를 해석해보겠습니다.

1. str은 null이 될 수 있다. -> `str: String?`
2. str이 null이면 startsWith는 실행하지 않고 null을 반환한다. -> `str?.startsWith("A")`
3. startWithA의 반환 값은 Null이 될 수 있다. -> `Boolean?`

## Safe Call, Elvis 연산자, !! 연산자

1. Safe Call `?.` - null이 아니면 뒤에 구문을 실행하고, null이면 null로 냅둔다.
2. Elvis `?:` - 앞의 연산 결과가 null이면 뒤의 값을 사용한다.
3. !! - Nullable이지만 곧 죽어도 Null일리가 없을 경우 사용합니다. `str!!.startsWith("A")`

3번의 경우 만약 Null이 들어온다면 NPE가 발생합니다.

# Type

## 타입 추론

1. Kotlin은 선언된 기본 값을 통해 타입을 추론합니다.
   1. val num = 3 -> Int로 추론
   2. val num = 3L -> Long으로 추론

## 타입 캐스팅

1. 타입 변환이 명시적으로 이뤄집니다.
   1. 안되는 케이스
      ```kotlin
      val num = 5 // 암시적 Int 추론
      val longNum: Long = num // 안됨. Type Mismatch
      ```
   2. 가능한 경우
      ```kotlin
      val num = 5 // 암시적 Int 추론
      val longNum: Long = num.toLong() // 가능
      ```
2. custom 객체 캐스팅

   1. 변수 타입 확인

   ```kotlin
   fun test(obj: Any) {
       if (obj is Member) {
           val member = obj as Member
           println(member.name)
       }
   }
   ```

   특정 클래스의 타입임을 확인하고자 하면, `{변수명} is {Type}`을 사용하면 됩니다.

   특정 클래스의 타입이 아닌 것을 확인하고자 하면, `{변수명} !is {Type}`을 사용하면 됩니다.

   타입으로 변환은 `{변수명} as {Type}`

   `{변수명} as? {Type}`을 사용하면 변수가 null이거나 type이 아닐 땐 null을 반환합니다.

   2. 스마트 캐스팅

      ```kotlin
      println(obj.name)
      ```

      와 같은 형식으로 명시적 캐스팅 없이 스마트 캐스팅이 가능합니다.

## 특별한 Type 3가지. Any, Unit, Nothing

### Any

1. java의 object. 최상위 타입
2. Any 자체는 not null이다. nullable하려면 `Any?`를 사용!

### Unit

1. Java의 void

### Nothing

1. 함수가 정상적으로 끝나지 않음을 표현함
2. 무조건 예외를 반환하는 함수, 무한 루프

# String 사용법

## 문자열 변수 사용법

문자열에서 변수 사용하기! -> `${변수}`

```kotlin
val member = Member("taek")
val str = "my name is ${member.name}"
```

or

문자열에서 변수 사용하기! -> `$변수`

```kotlin
val member = Member("taek")
val str = "my name is $member.name"
```

하지만 `${변수}`의 사용법이 더욱 권장된다

## 멀티라인 문자열

```kotlin
val str = """
ABC
DEF
GHI
""".trimIndent()
```

*trimIndent()*는 라인 별로 앞에 공백을 제거해준다.

---

# 연산자

코틀린은 객체를 비교할 때 비교연산자(>, <, <=, >=)를 사용하면 자동으로 compareTo를 호출함

동일성 비교(주소가 같은가)에는 `===`를 사용, 동등성 비교(값이 같은가)에는 `==`를 사용

`==`를 사용하면 간접적으로 equals를 호출

## 범위 연산자

`in`, `!in` : 컬렉션, 범위에 포함되어 있는지 확인

`a..b` : 닫힌 범위임 -> 1..100 (1부터 100까지)

---

# 조건문

## if-elif-else

if-else 구문은 자바와 동일하지만 코틀린의 `if-else`구문은 `Expression`이다.

```
Statement : 프로그램의 문장, 하나의 값으로 도출되지 않는다
Expression : 하나의 값으로 도출되는 문장, 변수에 바인딩이 가능함
```

```kotlin
fun scoreMapper(score: Int): String {
    return if (score > 90) {
        "A"
    } else {
        "A Under"
    }
}
```

해당 구분처럼 if문이 리턴값이나 변수에 바인딩이 가능하다. 따라서 3항 연산자가 필요없고 존재하지 않는다.

### when

자바에선 switch로 쓰이던 구문이 코틀린에선 when으로 사용됩니다.

```kotlin
fun scoreMapper(score: Int): String {
    return when (score) {
        in 100 downTo 90 -> {"A"}
        in 89 downTo 80 -> "B"
        else -> "C"
    }
}
```

```
when (값) {
조건부 -> 어떠한 구문
조건부 -> 어떠한 구문
else -> 어떠한 구문
}
```

으로 사용이 가능하다.

---

# 반복문

## for each

```kotlin
    val numbers = listOf(1,2,3,4)
    for (num in numbers) {
        println(num)
    }
```

in 뒤애는 `iterator`가 구현된 객체면 뭐든 가능

```
    for (i in 1..100) {
        println(i)
    }

   for (i in 100 downTo 1) {
        println(i)
    }

      for (i in 1..100 step 2) { // 2씩 올라감 1,3,5
        println(i)
    }
```

while은 자바와 동일하다.

# 코틀린 예외 핸들링

코틀린은 checked exception과 uncheked exception을 구분하지 않고, 모두 unchecked로 생각한다.

코틀린은 `throw with resources`가 없다. 대신 use라는 inline 확장 함수를 사용한다.

```
fun readPrinter(path: String) {
    BufferedReader(FileReader(path)).use { reader ->
        println(reader.readLine())
    }
}
```

# 함수

- 함수 반환 값이 Unit이면 생략 가능
- 함수가 하나의 결과 값이면 block 대신 `=`을 사용할 수 있다.
  ex)

```kotlin
fun max(a: Int, b: Int): Int =
    if (a > b) {
        a
    } else {
        b
    }
```

==

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

`=`을 쓸 땐 반환 타입 생략 가능

### default param

```kotlin
fun repeat(str: String, num: Int = 3) {
    for (i in 1..num) {
        println(str)
    }
}
```

### named param

```
repeat(str="123", num=3)
```

빌더처럼 사용이 가능하다

### 가변인자 vararg

```
fun printAll(vararg strings: String) {
    for (str in strings) {
        println(str)
    }
}

fun main() {
    printAll("A", "B", "C")
    printAll(*arrayOf("A", "B", "C")) // *는 배열 내부 값들을 ,처럼 꺼내주는 역할
}
```
