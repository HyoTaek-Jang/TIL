# 문제상황

아래와 같은 상황에서 어떤 식으로 Entity를 설계할 수 있을까?

```
금칙어를 기준으로 생각해보자.
하나의 금칙어는 여러 머천트에 적용된다.
하나의 금칙어는 여러 카테고리에 적용된다.
하나의 금칙어는 여러 동의어를 가진다.
```

# 상속 관계에는 어떤 종류가 있을까?

해당 예시를 갖고 코드를 짜기 전에 간단히 연관관계에 대해 알아봅시다.

## JPA 연관관계 매핑

기본적으로 객체의 참조와 테이블의 매핑은 다릅니다. *객체는 단방향 참조*를 사용하고 *테이블의 연관 관계는 양방향*입니다. 약간의 스포일러지만 객체에서 양방향 관계를 만드는 것은 단방향이 두 개 존재한다고 볼 수 있습니다. 더불어 객체를 양방향 연관관계로 만들면 이제 JPA는 어떤 정보(서로를 참조하는 두 객체의 값이 일치하지 않는 경우)를 믿을 지 헷갈릴 수 있습니다. 그렇기에 연관관계의 주인을 정하는 과정 또한 필수적입니다.

## @ManyToOne

@ManyToOne은 다대일 관계에서 사용합니다. 예를 들면, `여러 멤버는 하나의 팀을 가진다.` 이러한 예시가 있겠네요. 위의 경우에선 `여러 동의어는 하나의 금칙어를 가진다`라는 구문도 적용이 될 것 같습니다.

```java
// Synonym.class
@Entity
public class Synonym {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn
    private Prohibition prohibition;
}
```

```java
// Prohibition.class
@Entity
public class Prohibition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
```

`Synonym`에 `@ManyToOne`이 선언됐으므로 여러 동의어가 하나의 금칙어를 갖는 다는 구문이 만들어집니다.

더불어 `@JoinColumn`은 외래 키를 매핑할 때 사용되며, 필수는 아닙니다.

생략 시 책에선 `필드명 + _ + 참조 테이블 컬럼명`이 나온다고 하는데, 직접 실행했을 땐 `참조 테이블 컬럼명`으로 지정되네요.. ㅎㅎ

`Hibernate: alter table synonym add constraint FKrem7j0xjd1pp3cnqr62i7eavi foreign key (prohibition_id) references prohibition`

자 이렇게 @ManyToOne으로 금칙어와 동의어 간의 관계가 생성됐기에 저희는 _Synonym Entity_ 객체에서 *Prohibition*를 읽고 사용할 수 있습니다. JPA의 변경 감지 또한 사용할 수 있게 됐습니다.

해당 과정에서 ERD를 보면 분명히 PK를 통해 양방향 매핑이 되어있지만, 현재 상황에선 _Prohibition_ 클래스에서 _Synonym를 참조할 수 없습니다._ 이것이 객체 관계와 테이블 관계의 차이입니다.

## @OneToMany

@ManyToOne으로 동의어 -> 금칙어의 단방향 관계를 만들었으니, 이제 역으로 금칙어 -> 동의어의 관계를 생성해봅시다.

```java
@Entity
public class Prohibition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany
    private List<Synonym> synonyms;
}
```

기존 코드에서 하단 내용이 추가 됐습니다.

```java
    @OneToMany
    private List<Synonym> synonyms;
```

참고로 JPA에서 Collection을 사용할 때 Set보단 List 성능상 우수하다고 합니다.

Set을 사용했을 때 equals 연산이 추가로 필요하다 합니다.
by [JPA 연관 관계에서 set과 list 차이](https://joont92.github.io/jpa/%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC-%EB%B6%80%EA%B0%80%EA%B8%B0%EB%8A%A5/), [컬렉션과 부가기능](https://joont92.github.io/jpa/%EC%BB%AC%EB%A0%89%EC%85%98%EA%B3%BC-%EB%B6%80%EA%B0%80%EA%B8%B0%EB%8A%A5/)

이후 스프링부트를 실행하면 JPA는 총 테이블을 3개를 만듭니다.

```java
Hibernate: create table prohibition (id bigint generated by default as identity, name varchar(255), primary key (id))
Hibernate: create table prohibition_synonyms (prohibition_id bigint not null, synonyms_id bigint not null, primary key (prohibition_id, synonyms_id))
Hibernate: create table synonym (id bigint generated by default as identity, name varchar(255), prohibition_id bigint, primary key (id))
```

_create table prohibition_ 부분을 보면 어딜봐도 synonyms에 대한 이야기가 없습니다. 테이블 관계에서 synonyms에서 FK로 prohibition를 사용하는 구조입니다. 즉, @OneToMany는 객체 관계에서 양방향 매핑을 위한 용도라고 보시면 됩니다. 위에서 말했듯이 태생이 객체와 테이블 관계가 다르기 때문입니다.

그리고 실질적으로 사용할 땐 아래와 같이 사용할 것입니다.

```java
     @OneToMany(mappedBy = "prohibition")
    private List<Synonym> synonyms;
```

*mappedBy*라는 속성은 왜 필요할까요?

엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나기에 둘 사이에 차이가 발생할 수 있습니다. 그래서 둘 중 어떤 관계를 사용해서 외래 키를 관리할 지 결정하는 것이 mappedBy 속성입니다. 해당 속성을 통해 외래 키를 관리하는 연관관계의 주인을 정하게 됩니다.

- 주인은 mappedBy 속성을 사용하지 않고
- 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 합니다.

JPA에선 외래 키가 있는 곳을 연관관계의 주인으로 만들도록 설계했습니다. 이것이 직관적이고 개발에 용이합니다.

참고로 @ManyToOne에는 mappedBy 속성이 없는데 그 이유는 테이블에서 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키(FK)를 가집니다. 그렇기에 @ManyToOne은 항상 연관 관계의 주인이 되므로 mappedBy를 설정할 수 없고, 해당 속성조차 없는 것입니다.

더불어 위 로그를 보면 mappedBy가 없을 때, 왜 3개의 테이블이 생기나 찾아보고 고민했는데, 구글링으로 어떠한 정보가 있진 않았으나, 추측으로는 mappedBy로 연관관계의 주인을 정확히 명시하지 않으면 해당 관계가 다대다의 관계일 가능성도 있기에 테이블을 생성한 것이 아닌가 하는 생각을 해봤습니다.

# 위의 예시는 어떻게 작성할 수 있을까?

커다란 구조는 위 예시와 비슷하게 만들 수 있을 것 같습니다.

```java
// Category.class
@Entity
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    private Prohibition prohibition;
}

//Merchant.class
@Entity
@Data
public class Merchant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    private Prohibition prohibition;
}

//Synonym.class
@Entity
@Data
public class Synonym {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne
    private Prohibition prohibition;
}

//Prohibition
@Entity
public class Prohibition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "prohibition")
    private List<Synonym> synonyms;

    @OneToMany(mappedBy = "prohibition")
    private List<Merchant> merchants;

    @OneToMany(mappedBy = "prohibition")
    private List<Category> categories;
}
```

하지만 위의 구조만 갖고 get, set을 한다면 몇가지 문제가 생길 수 있습니다.
만약 주인이 아닌 곳에만 값을 입력하고 저장한다면 null이 담긴 상태로 저장될 것입니다.

```java
    @Test
    void relationTest() {
        Prohibition prohibition = new Prohibition();
        Prohibition savedProhibition = prohibitionRepository.save(prohibition);

        Synonym synonym = new Synonym();
        synonym.setProhibition(savedProhibition);
        synonymRepository.save(synonym);

        Synonym synonym1 = new Synonym();
        synonym1.setProhibition(savedProhibition);
        synonymRepository.save(synonym1);
    }
```

```
# SELECT * FROM SYNONYM;
ID  NAME  	PROHIBITION_ID
1	null	null
2	null	null
```

왜냐하면 `Prohibition`은 연관관계의 주인이 아니기 때문입니다. 그렇기에 객체 관점으로 바라보며 연관관계 주인인 synonym에도 prohibition 주입이 필요합니다. 따라서 Synonym 클래스에 아래와 같은 메서드를 통해 값을 세팅한다면 객체 관점에서도 양방향 매핑과 유사하게 동작할 수 있습니다.

```java
    public void setProhibition(Prohibition prohibition) {
        this.prohibition = prohibition;
        prohibition.getSynonyms().add(this);
    }
```

만약 위 코드에서 set을 하고 추후 다른 Prohibition으로 값을 바꾼다고 했을 때, 두 개의 Prohibition에서 하나의 Synonym을 바라볼 수 있습니다. 따라서 기존 Prohibition의 관계를 지워주는 코드가 있는 것이 더욱 안전합니다.

```java
    public void setProhibition(Prohibition prohibition) {
        // 기존 관계 제거
        if(this.prohibition != null){
            this.prohibition.getSynonyms().remove(this);
        }

        this.prohibition = prohibition;
        prohibition.getSynonyms().add(this);
    }
```
